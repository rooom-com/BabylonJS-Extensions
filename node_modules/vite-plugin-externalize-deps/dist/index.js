import { existsSync as l, readFileSync as f } from "node:fs";
import { builtinModules as x } from "node:module";
import { join as g } from "node:path";
const h = (s) => JSON.parse(f(s).toString()), y = (s = {}) => {
  const n = {
    deps: !0,
    devDeps: !1,
    except: [],
    include: [],
    nodeBuiltins: !0,
    optionalDeps: !0,
    peerDeps: !0,
    useFile: g(process.cwd(), "package.json"),
    // User options take priority.
    ...s
  };
  return {
    name: "vite-plugin-externalize-deps",
    config: (E, m) => {
      if (!l(n.useFile))
        throw new Error(`[vite-plugin-externalize-deps] The file specified for useFile (${n.useFile}) does not exist.`);
      const r = /* @__PURE__ */ new Set(), {
        dependencies: o = {},
        devDependencies: i = {},
        optionalDependencies: p = {},
        peerDependencies: c = {}
      } = h(n.useFile);
      n.deps && Object.keys(o).forEach((e) => {
        const t = new RegExp(`^${e}(?:/.+)?$`);
        r.add(t);
      }), n.devDeps && Object.keys(i).forEach((e) => {
        const t = new RegExp(`^${e}(?:/.+)?$`);
        r.add(t);
      }), n.nodeBuiltins && x.forEach((e) => {
        const t = new RegExp(`^(?:node:)?${e}$`);
        r.add(t);
      }), n.optionalDeps && Object.keys(p).forEach((e) => {
        const t = new RegExp(`^${e}(?:/.+)?$`);
        r.add(t);
      }), n.peerDeps && Object.keys(c).forEach((e) => {
        const t = new RegExp(`^${e}(?:/.+)?$`);
        r.add(t);
      });
      const a = Array.from(r), d = (e) => n.except.some((t) => typeof t == "string" ? t === e : t.test(e)), u = (e) => n.include.some((t) => typeof t == "string" ? t === e : t.test(e));
      return {
        build: {
          rollupOptions: {
            external: (e) => d(e) ? !1 : u(e) ? !0 : a.some((t) => t.test(e))
          }
        }
      };
    }
  };
};
export {
  y as externalizeDeps
};
//# sourceMappingURL=index.js.map
